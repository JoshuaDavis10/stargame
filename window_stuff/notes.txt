NOTES ON X WINDOW SYSTEM

https://www.x.org/releases/X11R7.7/doc/libxcb/tutorial/index.html#intro
https://www.youtube.com/watch?v=IPGROgWnI_8

Client-Server model:
	If I understand correctly, a program that is using the X window system
is a client. The X server runs on the OS and controls the window, window
input, etc. The client makes requests to the X server to get information
about the window, and to request that the X server do things to the window
?? I think.

XCB:
- The goal behind XCB is to create an X window system protocol
implementation that is lightweight compared to Xlib
- If I understand correctly, XCB is very direct and allows very direct
and specific control of X protocol requests and responses.

GUI program with X windows (general flow):
1. Perform initialization routines.
2. Connect to the X server.
3. Perfrom X-related initialization.
4. While (not finished):
	a. Receive the next event from the X server.
	b. Handle the event, possibly sending various drawing requests to the 
	X server.
	c. If the event was a quit message, exit the loop.
5. Close down the connection to the X server.
6. Perform cleanup operations.


XCB programs
- XCB installation: https://xcb.freedesktop.org/ 
	- okay it looks like I had xcb installed already (probably from
	doing raylib stuff let me double check... 
	- ^ looks like libx11-dev includes xcb, X11 stuff, everything needed
	so not that crazy. I'm not gonna go build the entire library lol.
	I'm gonna update libx11-dev with package manager tho I guess.
- link programs to XCB library when compiling

7) checking connection info
- I'm going to write/build/run the example program and take notes about 
what I learn. "screen" represents a monitor? or something else?

screen struct:
	typedef struct {
	    xcb_window_t   root;
	    xcb_colormap_t default_colormap;
	    uint32_t       white_pixel;
	    uint32_t       black_pixel;
	    uint32_t       current_input_masks;
	    uint16_t       width_in_pixels;
	    uint16_t       height_in_pixels;
	    uint16_t       width_in_millimeters;
	    uint16_t       height_in_millimeters;
	    uint16_t       min_installed_maps;
	    uint16_t       max_installed_maps;
	    xcb_visualid_t root_visual;
	    uint8_t        backing_stores;
	    uint8_t        save_unders;
	    uint8_t        root_depth;
	    uint8_t        allowed_depths_len;
	} xcb_screen_t;

	functions used in this section:
	- xcb_setup_roots_iterator
		- this returns an xcb_xcreen_iterator_t
		- it takes an xcb_setup_t pointer as its only paramter
			- xcb_get_setup(xcb_connection_t *c) returns a pointer
			to the xcb_setup_t struct associated with the connection c
			- idk really what that means but we need the xcb_setup_t to 
			get passed to xcb_setup_roots_iterator
		- there's no comments on how it works just the function
		declaration (/usr/include/xcb/xproto.h)
		- the returned iterator (I assume) has a list of xcb_screen_t's
	- xcb_screen_next
		- takes pointer to an xcb_screen_iterator_t 
			- decreases xcb_screen_iterator_t.rem value by one
			- moves xcb_screen_iterator_t.data is pointed to the next
			element (i.e. next xcb_screen_t)
			- if rem is 0, I think that is the last element

	so anyways, they have the iterator code to get the xcb_screen_t struct
	for screen 0 (which I guess is the first screen?). I don't quite get
	all of it, but they basically iterate through the iterator until it's
	rem value is 0, or the screen_nbr (which they got from xcb_connect) 
	is 0. Either way we're just trying to get an xcb_screen_t pointer to
	the "first" screen, so we can access information about it.

NOTE: should use xcb_connection_has_error function after calling
xcb_connect a connection to make sure it worked

okay that worked! it outputs 1920 x 1080 when I have one screen
but 3840 when I have two screens which is interesting. I guess
it treats it like one screen? makes sense

8) creating a window

NOTE: xcb_window_t is just a typedef of uint32_t

	xcb_window_t xcb_generate_id(xcb_connection_t *c);
	- this generates an id for some X object that will be used in future
	- so it doesn't really do anything except reserve that ID I believe
	- returns -1 on failure so do error handling for that
		- NOTE: the function declaration says it returns a uint32_t, so...

	we then pass that ID to the xcb_create_window function.
	Here's the list of xcb_create_window parameters and thoughts about
	them:
	- depth: idk but example code just copies from parent (root) i.e.
	parent window which I guess is like the desktop GUI? 
	XCB_COPY_FROM_PARENT
	- wid: ID of the window -> generated by xcb_generate_id
	- parent: screens have a root value which is a window so I assume
	that's the "root" window
	- x position of window (top - left corner)
	- y position of window (top - left corner)
	- width of window (in pixels)
	- height of window (in pixels)
	- border width (in pixels)
	- class:  copy from parent, input/output, and input only are the 
	options (from looking through xproto.h)
	- visual: uint32_t... idrk what it means TODO: look this up or smn
	but screen->root_visual is what is passed (so the screen stores a 
	bunch of info: root, root_visual, root_depth, and I think that's it,
	about it's "root" window, and windows created can inherit those 
	values from root).
	XCB_COPY_FROM_PARENT <- can also be used here but example doesn't
	for some reason. I'm going to try it cuz the xcb header says it should
	work
	- value_mask: setting to 0 in this example, I think they will
	cover it later
	- *value_list: setting to NULL in this example, I think they
	will cover it later

	xcb_map_window to map window
	xcb_flush to flush commands to window
	NOTE: notes are in the comments, I should have put them here tho lol
	cuz now I have fat comments in the code

9) drawing

	Graphics Context

	need to get an id for xcb_gcontext_t (just a uint32_t)	
	xcb_create_gc creates graphics context:

	xcb_void_cookie_t xcb_create_gc (xcb_connection_t *c,
                                 xcb_gcontext_t    cid,
                                 xcb_drawable_t    drawable,
                                 uint32_t          value_mask,
                                 const uint32_t   *value_list);

	value_mask is I believe a bitwise or of different "values" that
	will then be passed as the value list. value_mask indicates which
	values will be found in the value_list.
	- in our case, XCB_GC_FOREGROUND is value_mask. I believe this
	indicates that the value we pass is the color to use for
	foreground?
	- screen->black_pixel is used as our value_list value bc...
	I guess that indicates to use black?

	drawable parameter... it needs to have the same root/depth
	as whatever you want to use I guess? so we will just pass
	root window (i.e. first screen's root: screen->root)

	connection and cid are fairly obvious as to what they are


	Changing Graphics Context Attributes

	NOTE: this is very intuitive given the xcb_create_gc function (i.e.
	very similar parameters and same system for setting values)
	- xcb_change_gc function
		xcb_void_cookie_t xcb_change_gc (
		/* The XCB Connection */
		xcb_connection_t *c,           
		/* The Graphic Context */
		xcb_gcontext_t    gc,          
		/* Components of the Graphic Context that have to be set */
		uint32_t value_mask,  
		/* Value as specified by value_mask */
		const uint32_t *value_list); 

	again, note that the values need to be specified in a certain order
	(as seen in enum list below):

    XCB_GC_FUNCTION
    XCB_GC_PLANE_MASK
    XCB_GC_FOREGROUND
    XCB_GC_BACKGROUND
    XCB_GC_LINE_WIDTH
    XCB_GC_LINE_STYLE
    XCB_GC_CAP_STYLE
    XCB_GC_JOIN_STYLE
    XCB_GC_FILL_STYLE
    XCB_GC_FILL_RULE
    XCB_GC_TILE
    XCB_GC_STIPPLE
    XCB_GC_TILE_STIPPLE_ORIGIN_X
    XCB_GC_TILE_STIPPLE_ORIGIN_Y
    XCB_GC_FONT
    XCB_GC_SUBWINDOW_MODE
    XCB_GC_GRAPHICS_EXPOSURES
    XCB_GC_CLIP_ORIGIN_X
    XCB_GC_CLIP_ORIGIN_Y
    XCB_GC_CLIP_MASK
    XCB_GC_DASH_OFFSET
    XCB_GC_DASH_LIST
    XCB_GC_ARC_MODE 

	Drawing Stuff
	- in this section they explain how to draw:
		> points
		> line segments
		> rectangles
		> circular (elliptical, really) arcs

	annoyingly, they kind of skip over how to set the background
	to WHITE, but maybe they talk about it in next section more.

	BUT, it looks like there's a separate enum for value_mask, value_list
	for window creations (and I don't know if there's a function to change
	window attributes like there is for graphics context)
	
	Anyways, its XCB_CW_* values that are used for windows. (NOTE: these
	values are stored in the xcb_cw_t enum in xproto.h)
	so they do XCB_CW_BACK_PIXEL, and set that to screen->white_pixel.
	Also, the set an XCB_CW_EVENT_MASK value to XCB_EVENT_MASK_EXPOSURE,
	which I guess is like telling the window which events to respond to?

	NOTE: from reading proto.h, XCB_CW_EVENT_MASK value determines: 
	"the event-mask defines which events the client is interested in
	for this window"

	anyways, the drawing functions all sort of follow a pattern

	xcb_void_cookie_t xcb_poly_point(  
		/* The connection to the X server */
		xcb_connection_t  *c,               
		/* Coordinate mode, usually set to XCB_COORD_MODE_ORIGIN */
		uint8_t            coordinate_mode, 
		/* The drawable on which we want to draw the point(s) */
		xcb_drawable_t     drawable,        
		/* The Graphic Context we use to draw the point(s) */
		xcb_gcontext_t     gc,              
		/* The number of points */
		uint32_t           points_len,      
		/* An array of points */
		const xcb_point_t *points);         

	They all follow that pattern of passing connection, drawable and
	context, then passing number of <thing to draw> then a pointer that
	points to an array of <things to draw>

	xcb_poly_fill_* <- same as xcb_poly_* but fills in 

	okay, this is enough to screw around with for sure

	last thing is the event stuff
	xcb_wait_for_event(xcb_connection_t *c) returns a pointer to an 
	xcb_generic_event_t I believe. Unforunately, due to what I'd probably
	consider bad design... it dynamically allocates an event every time
	that gets stored at the pointer it returns. since we're doing a loop,
	we are then dynamically allocating an event every loop and then freeing
	it at the end of the loop lol

	I believe since we've set the XCB_CW_EVENT_MASK to be fore exposure
	events or whatever, basically we just check for XCB_EXPOSE whenever
	we get an event, and then draw stuff (switch statement on
	e->response_type) 

	here it is:
	typedef struct {
	    uint8_t   response_type;  /**< Type of the response */
	    uint8_t  pad0;           /**< Padding */
	    uint16_t sequence;       /**< Sequence number */
	    uint32_t pad[7];         /**< Padding */
	    uint32_t full_sequence;  /**< full sequence */
	} xcb_generic_event_t;

	okay, turns out IN THE NEXT SECTION this event stuff gets much
	more well defined


10) X events

	Registering for Events

	basically, you register the window for events when you call
	xcb_create_window by passing appropriate values to value_mask and 
	value_list (NOTE: you can pass other attributes too, not just 
	events to register for)

	you can also change attributes after window creation using
	xcb_change_window_attributes(connection, window id, value_mask, 
	value_list);


	Event Loop

	2 ways to receieve events:
		1) xcb_wait_for_event(xcb_connection_t *c);
			- blocking
		2) xcb_poll_for_event(xcb_connection_t *c);
			- non-blocking
			- it looks like the link at top of this file for the 
			documentation might be outdated cuz it says xcb_poll_for_event
			has 2 parameters. but either way the xcb.h on my computer
			has 1 param so.
			- also note that this function returns NULL if theres no
			events on the queue

		these return event structures, and they need to be freed.

		the way xcb_poll_for_event works means you have to restructure
		event loop to handle the case when it returns NULL (i.e. no
		event). 

	Expose Events

	expose events occur if:
	
    - A window that covered part of our window has moved away, 
	exposing part (or all) of our window.
    - Our window was raised above other windows.
    - Our window mapped for the first time.
    - Our window was de-iconified.

	when they happen, we should handle them I guess?
	here's the struct that gets returned from an expose event (i.e.
	returned by xcb_wait_for_event/xcb_poll_for_event)

	typedef struct {
		/* The type of the event, here it is XCB_EXPOSE */
    	uint8_t      response_type; 
    	uint8_t      pad0;
    	uint16_t     sequence;
		/* The Id of the window that receives the event (in case */
    	/* our application registered for events on several windows */
    	xcb_window_t window;        
		/* The x coordinate of the top-left part of the window that 
		needs to be redrawn */
    	uint16_t     x;             
		/* The y coordinate of the top-left part of the window that 
		 needs to be redrawn */
    	uint16_t     y;             
		/* The width of the part of the window that needs to be redrawn */
    	uint16_t     width;         
		/* The height of the part of the window that needs to be redrawn */
    	uint16_t     height;        
    	uint16_t     count;
	} xcb_expose_event_t;

	Getting User Input
		Mouse press/release

			okay so there's 2 event types here that return the same
			struct (i.e. one is typedef'd to the other. see below).

			typedef xcb_key_press_event_t xcb_key_release_event_t;

			XCB_EVENT_MASK_BUTTON_PRESS
			XCB_EVENT_MASK_BUTTON_RELEASE

			^ that's what we'd pass for our event mask when creating
			window if we want to be registered for mouse press/release
			events.

			typedef struct xcb_button_press_event_t {
			    uint8_t         response_type;
			    xcb_button_t    detail;
			    uint16_t        sequence;
			    xcb_timestamp_t time;
			    xcb_window_t    root;
			    xcb_window_t    event;
			    xcb_window_t    child;
			    int16_t         root_x;
			    int16_t         root_y;
			    int16_t         event_x;
			    int16_t         event_y;
			    uint16_t        state;
			    uint8_t         same_screen;
			    uint8_t         pad0;
			} xcb_button_press_event_t;

			event_x and event_y are within window I believe, but 
			root_x/root_y are probably the x/y of the root window? or 
			relative to the root window? not sure, good question tho.

			'state' value is a bitwise or of which buttons have actually
			been pressed:

				XCB_BUTTON_MASK_1
    			XCB_BUTTON_MASK_2
    			XCB_BUTTON_MASK_3
    			XCB_BUTTON_MASK_4
    			XCB_BUTTON_MASK_5
    			XCB_MOD_MASK_SHIFT
    			XCB_MOD_MASK_LOCK
    			XCB_MOD_MASK_CONTROL
    			XCB_MOD_MASK_1
    			XCB_MOD_MASK_2
    			XCB_MOD_MASK_3
    			XCB_MOD_MASK_4
    			XCB_MOD_MASK_5 

			I think 1,2,3,4,5 are the buttons on the mouse,
			then shift, lock, control I think indicate if those keys
			are down... not sure what the XCB_MOD_MASK_1-5 ones mean tho.
			doesn't seem particularly important for my purposes tho.
			(SHIFT/CONTROL clicking are relevant tho)

		Mouse move

			so, there's 2 types of mouse move events. one is just for
			general movement, like if the mouse moves at all, that's:

				XCB_EVENT_MASK_POINTER_MOTION <- to register for it

			2nd type is mouse movement when button(s) are pressed

				XCB_EVENT_MASK_BUTTON_MOTION <- if any button is down
				XCB_EVENT_MASK_BUTTON_X_MOTION <- where X is 1,2,3,4, or 5
										i.e. if that particular
										button is down

			struct returned by event (looks like it's practically
			identical to mouse press/release event struct): 

				typedef struct {
					/* The type of the event */
				    uint8_t         response_type; 
				    uint8_t         detail;
				    uint16_t        sequence;
					/* Time, in milliseconds the event took place in */
				    xcb_timestamp_t time;          
				    xcb_window_t    root;
				    xcb_window_t    event;
				    xcb_window_t    child;
				    int16_t         root_x;
				    int16_t         root_y;
					/* The x coordinate of the mouse when the 
					event was generated */
				    int16_t         event_x;       
					/* The y coordinate of the mouse when the 
					event was generated */
				    int16_t         event_y;       
					/* A mask of the buttons (or keys) during the event */
				    uint16_t        state;         
				    uint8_t         same_screen;
				} xcb_motion_notify_event_t;

			so yeah, do with that what you will.

		Mouse pointer enter/leave

			typedef struct {
				/* The type of the event */
			    uint8_t         response_type; 
			    uint8_t         detail;
			    uint16_t        sequence;
				/* Time, in milliseconds the event took place in */
			    xcb_timestamp_t time;          
			    xcb_window_t    root;
			    xcb_window_t    event;
			    xcb_window_t    child;
			    int16_t         root_x;
			    int16_t         root_y;
				/* The x coordinate of the mouse when the  
				event was generated */
			    int16_t         event_x;       
				/* The y coordinate of the mouse when the  
				event was generated */
			    int16_t         event_y;       
				/* A mask of the buttons (or keys) during the event */
			    uint16_t        state;         
				/* The number of mouse button that was clicked */
			    uint8_t         mode;          
			    uint8_t         same_screen_focus;
			} xcb_enter_notify_event_t;

			typedef xcb_enter_notify_event_t xcb_leave_notify_event_t;

			
		    xcb_event_enter_window_t: 
				notify us when the mouse pointer enters any of our 
				controlled windows.
		    xcb_event_leave_window_t: 
				notify us when the mouse pointer leaves any of our 
				controlled windows.
		
			very similar to mouse button/move events it seems. idk
			what mode and same_screen_focus are tho. I'm sure there's
			resources to get more in-depth on various event types.
			I don't know if this is an event we really care about yet,
			but will matter for like a SHIPPABLE Linux X Window platform
			layer.

		Keyboard focus

			basically, only one window gets the keyboard focus (i.e.
			keystrokes get sent to that window). Apparently, there's 
			ways to set the keyboard focus. Anyways, what matters is
			just handling keyboard events when we get them. I don't
			really super care about switching keyboard focus or smn
			rn. that might matter if we have a program that generates/uses
			multiple windows.

		Keyboard press/release

			
			XCB_EVENT_MASK_KEY_PRESS: 
				notify us when a key was pressed while any of our 
				controlled windows had the keyboard focus.
    		XCB_EVENT_MASK_KEY_RELEASE:
				notify us when a key was released while any of our 
				controlled windows had the keyboard focus. 

				typedef struct {
					/* The type of the event */
					uint8_t         response_type; 
    				xcb_keycode_t   detail;
    				uint16_t        sequence;
					/* Time, in milliseconds the event took place in */
    				xcb_timestamp_t time;          
    				xcb_window_t    root;
    				xcb_window_t    event;
    				xcb_window_t    child;
    				int16_t         root_x;
    				int16_t         root_y;
    				int16_t         event_x;
    				int16_t         event_y;
    				uint16_t        state;
    				uint8_t         same_screen;
				} xcb_key_press_event_t;

				typedef xcb_key_press_event_t xcb_key_release_event_t;

				I'm realizing that this documentation is pretty 
				incomplete. Either way, the "detail" field in the
				event struct is the actual keycode that is return. 
				Now how does that translate to the key that was pressed?
				No idea. I'm going to look for an enum in one of the
				headers to see.

				good new, we're approaching halfway through this
				documentation.

				Unfortunately, not finding anything.
				look into this. I need to know what the keycode
				values actually mean and how to use them.

				^ hopefully this helps. 
	Notes on "complete example" at end of events section

		Okay, I'm not going to recreate their example one-for-one because
		that would not be a good learning experience. I'm just gonna try
		to handle the following events: mouse button press/release, mouse
		motion, mouse enter/leave (i guess, why not?) keyboard 
		press/release. Seems fair

		how to get ASCII keycodes or at least smn informative
		from keypress event? Link source

		https://www.exchangetuts.com/obtain-keyboard-layout-and-keysyms-with-xcb-1640773744437952
		^ hope this helps some. looks like you can get a keyboard mapping
		or smn, and from that you can figure out what different keycodes
		mean. THIS IS IMPORTANT!!! so make sure it's set up before you
		continue, bc we will 100% want our game to know what freaking
		key is getting pressed lol

		looks like keysyms are ascii values but I'm not 100% sure
		so write a function that maps keycodes to keysyms.

		NOTE: xev is just an executable (i guess it came with xcb?)
		that creates a window and outputs info as events happen.
		THIS IS ACTUALLY REALLY HELPFUL!!! it looks like they do a 
		keymap notify thing on enter to setup the keymapping and then
		they are able to show the sym for each keypress! is there 
		source code? idk but it's just like good to show how things work
		with an example.

		https://www.x.org/releases/current/doc/xproto/x11protocol.html#keysym_encoding
		Appendix A
		well this is dope ^ it's the X protocol LOL. Anyways it has a list
		of keysymbols and stuff

		so the above 2 links
		1) show how to get keysyms from keycodes
		2) show what different keysyms mean

		also xmodmap -pk xmodmap -pke

xcb_keysym_t *xcb_get_keyboard_mapping_keysyms(
				const xcb_get_keyboard_mapping_request_t *reply);

		^ the link for getting keysyms does pointer arithmetic that
		doesn't really make sense to me, but it looks like we can
		get the keysyms with the function above
		So if you get keysyms and length, you should then have 
		all the keysyms accessible, not super sure.

		also, it's okay to not have a super generic solution. like
		honestly just get the keysyms that would actually be used in
		a starcraft-like RTS game

		OKAY: so I implemented a function to load all the keysymbols
		into an array. Index 7 of that array will store the keysymbol
		for keycode 7 for example.

		Looks like that's all working, but I'm getting a crash.
		It looks like I'm getting a segfault when the call to
		xcb_create_window occurs

		the only parameters I could think of that would cause issues are:
		- x_server_connection
		- x_window_id
		- x_screen->root
		- x_win_value_mask
		- x_win_value_list

		okay, so it looks like the changes I made to the connection
		in the setup keysymbol table function screwed up the connection
		so that creating the window didn't work... so anyways I put
		the symbol loading thing after creating the window, and that
		fixed it

		BUT NOW! now the draws won't work and events aren't getting
		received... so I'm somehow screwing up the x_server_connection
		...

		okay turns out i had a bug where I was looping through keysimcount
		instead of max key codes so I WAY overwrote the symbol table
		and broke everything

		got keycode -> keysym working.

		LIST OF KEYS I WILL CARE RIGHT NOW:
		- all a-z, spacebar
		- numbers
		- F keys
		- esc, tab, shift, control, arrow keys, enter
		- I can always add keys later, but those are really 
		the only ones I can think of for RTS game

		I consulted the xorg link somewhere up there ^ to get the keysyms
		for the weird stuff, but looks like number keys/letter keys
		are just ASCII

		everything's working! program now prints the keys that I press

		MOUSE BUTTON EVENTS NOW!
			okay, so I'm pretty sure the documentation is lying to me
			they say the state value is which button is pressed, but
			you should see what the detail value is... bc idk
			do some googling if the results are not obvious

			I'm also definitely going to ignore the mod stuff, bc
			I can just check based on keyboard input

			Okay, so state does not change based on button presses,
			but detail (at least for the mouse I have), gives
			1 - left
			3 - right
			2 - mouse wheel click
			4 - mouse wheel up
			5 - mouse wheel down
			8, 9 are side buttons <- I don't think I need to support
				these right now honestly, I don't care enough
			
			OKAY, i got it set up to print mouse buttons when they're
			pressed teehee

		OKAY NOW MOUSE MOVEMENT EVENTS!

			Okay, I'm able to track mouse position. Just need
			to store that in a state now. same with button
			press stuff

		mouse leave/enter events?
			- I guess I'll just store a flag in the state that
			says whether the mouse is in the window or not

		Alright, I got it done


		Okay, so it looks like you have to like register your
		window for the WM_DELETE_WINDOW message?

		Now, how that is done is somewhat convoluted, but
		looks like we gotta call this function

			xcb_change_property (xcb_connection_t *c,
			                     uint8_t           mode,
			                     xcb_window_t      window,
			                     xcb_atom_t        property,
			                     xcb_atom_t        type,
			                     uint8_t           format,
			                     uint32_t          data_len,
			                     const void       *data);

			connection is obvious
			XCB_PROP_MODE_REPLACE (idk) i guess we're just replacing
				the property? idk
			window is obvious,
			property... this is where we want to pass WM_PROTOCOLS,
				as an atom... not really sure what an atom is. 
				Okay, its a uint32_t... lol what idk what's happening

			But it looks like xcb_intern_atom() will setup an 
			internal atom (i.e. return one) then xcb_intern_atom_reply() 
			will will get the reply of that atom? i.e. an
			xcb_intern_atom_reply_t*
			and that reply has an atom... and that's what we want...
			not convoluted at all

		still have to do stuff for all the other events haha.
		anyways, that's how we get the property atom we want
		and the data? the data is gonna be a pointer to an atom in
		this case I guess... according to the code I'm reading on GitHub
		rn. link below:

		https://github.com/thetinkeringee/gui_examples/blob/main/xcb/example02/main.c

		then the type is just XCB_ATOM apparently.
		so we need the property, the type of the property, and the actual
		data for the change of the property (i.e. the wm_delete_window
		atom I guess.

		format is 32, cuz 32-bit values (since the atom is 32 bit I
		think).
		data_len is 1, cuz it's just the one atom
		pointer to wm_delete_window atom for data

		Okay, then when you get the client message, basically
		check it's data (now it's data, confusingly has 3 types of data,
		8 bit, 16 bit, 32 bit -> data8, data16, data32, and corresponding
		amounts of each), anyways check data32 to see if it is in fact
		the x_atom_wm_delete_window value or whatever

		Okay, I did all of that, but I'm still not receiving any events
		when I close the thang

		Can confirm that the property is getting registered and all dat.
		using xprop program, clicked on window and it showed ghat
		WM_PROTOCOLS included WM_DELETE_WINDOW, i.e. the window
		is regestered for that event... it is simply not getting
		that event?

		so what the heck? 

		I am very upset. but it's okay, because the bug has been fixed
		so, in one of these things I found, the 'type' parameter
		passed to xcb_change_property is just "4" LOL with no explanation
		but its XCB_ATOM on the github thing I found...

		OKAY I FIGURED IT OUT LOL...
		so the value: XCB_ATOM_ATOM is 4
		but the value XCB_ATOM IS 5!
		XCB_ATOM IS AN OPCODE
		XCB_ATOM_ATOM  is a value in the xcb_atom_enum_t LOLLLL
		dude, that's insane. idk wtf that opcode is used for but
		anyways, using XCB_ATOM_ATOM instead of XCB_ATOM fixed it

https://lists.freedesktop.org/pipermail/xcb/2010-December/006714.html

		that mfer in the github link probably didn't even run the program
		... unless this change happened like in an update. idk lol
		I'm starting to question how cross compatible this thing will 
		be bruh

		anyways, the application friggin' closes now

		TODO: store all the info you got into a global state

11) text + fonts

	TODO: do I really care about this section?
	NOTE: these sections are short anyways and you
	will work through them very fast now that you have 
	a good understanding of the library

12) interacting with window manager

	TODO: do I really care about this section?
	NOTE: these sections are short anyways and you
	will work through them very fast now that you have 
	a good understanding of the library

13) window operations

	TODO: I need to get window resizing figured out, maybe keep a 
	consistent aspect ratio? + be able to full screen
	- get window resize event
	- manually resize window to preserve aspect ratio

14) color

	NOTE: this the good stuff I think.

15) bitmaps/pixmaps (images)

	NOTE: this the good stuff I think.

	xcb_copy_ somethin. it's kind of like the bitblit on window?
	but check what handmade hero uses again so that you can do
	smn similar

TODO: this might be where you want to stop and start working on
the actual game (i.e. having a window that does everything you need
to start writing a game, cursor stuff is like a fun thing you could 
come back to later lol)

16) Cursor

FULLSCREEN:
- so it looks like (at least on Ubuntu) you fullscreen similarly to
registering for WM_DESTROY events, except instead with _NET_WM_STATE/
_NET_WM_STATE_FULLSCREEN
- it also will fullscreen regardless of like screen size I guess
anyways, I'll just set it to screen size either way

GRAPHICS:
- it's okay to screw this up the first few times, just try things
- I think there's an xcb_copy_smn function that will copy pixels to 
screen?
- okay so I need to create a pixmap then fill it with stuff, then use
xcb_copy_area to copy that pixmap to the window
- http://metan.ucw.cz/blog/things-i-wanted-to-know-about-libxcb.html
^^^ this will help a ton
- got it working!!! NOTE: also added error checking to the event loop
(asserts for now)
