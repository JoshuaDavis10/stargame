#include "cpu_render.c"

#include <math.h> /* TODO: replace with faster/better sqrt */

/* TODO: temp? */
#define NUM_UNITS 2
#define NUM_ENEMIES 2

#define MOVE_SPEED_BIG 0.1f
#define MOVE_SPEED_MELEE 0.1f
#define MOVE_SPEED_RANGED 0.1f

typedef enum {
	ENTITY_BIG,
	ENTITY_MELEE,
	ENTITY_RANGED,
	ENTITY_HARVESTER,
	ENTITY_BARRACKS,
	ENTITY_NEXUS,
	ENTITY_ENUM_LENGTH
} entity_type;

typedef struct {
	i32 x;
	i32 y;
	i32 w;
	i32 h;
} struct_aabb;

typedef struct {
	struct_entity *aggro_target;
	f32 x;
	f32 y;
	f32 progress;
	f32 health;
	f32 target[2];
	entity_type type;
} struct_entity;

typedef struct {
	struct_entity *units;
	struct_entity *buildings;
	struct_entity *enemies;
	struct_entity *selected;
	u64 money;
	f64 last_time;
	f64 time_elapsed;
} struct_game_state;

/* NOTE: this goin' be useful for a looong time so keeping it */
b8 check_collision_aabb(struct_aabb first, struct_aabb second);

/* NOTE: x and y are center of unit */
void draw_entity_in_buffer(
		u8 *pixel_buffer,
		u16 pixel_buffer_width,
		u16 pixel_buffer_height,
		struct_entity entity,
		struct_rgba_color color);

void update_entity(struct_entity *entity);

static b8 game_initialized = false;
static struct_game_state *state = 0;
static struct_memory_arena game_memory_arena;

/* TODO: macros */
static struct_rgba_color blue = {0, 0, 255, 0};
static struct_rgba_color white = {255, 255, 255, 0};
static struct_rgba_color red = {255, 0, 0, 0};
static struct_rgba_color black = {0, 0, 0, 0};
static struct_rgba_color purple = {255, 0, 255, 0};

/* NOTE: runs every frame */
void game_update_and_render(
		void *game_memory,
		u64 game_memory_size,
		u8 *pixel_buffer, 
		u16 pixel_buffer_width,
		u16 pixel_buffer_height,
		x_input_state *input) /* NOTE: passing pointer so as not to 
									push massive input struct onto stack
									*/
{
	/* initialize */
	if(!game_initialized)
	{
		/* memory */
		_assert(game_memory != 0);
		/* TODO: assert game memory size is large enough */
		memory_arena_initialize(
				&game_memory_arena, 
				game_memory,
				game_memory_size);
		_assert(game_memory_arena.memory != 0);
		state = memory_arena_allocate(&game_memory_arena, sizeof(*state));
		_assert(state != 0);

		/* state */
		state->last_time = get_time_ms();
		/* TODO: this assumes unit/building lists are a constant size. do 
		 * we want to just have that be the case in this game?
		 */
		state->units = memory_arena_allocate(
				&game_memory_arena,
				sizeof(*(state->units)) * NUM_UNITS);
		_assert(state->units != 0);
		state->enemies = memory_arena_allocate(
				&game_memory_arena,
				sizeof(*(state->enemies)) * NUM_ENEMIES);
		_assert(state->enemies != 0);

		state->units[0].aggro_target = 0;
		state->units[0].x = 300.0f;
		state->units[0].y = 300.0f;
		state->units[0].target = {400.0f, 200.0f};
		state->units[0].health = 100.0f;
		state->units[0].progress = 0.0f;
		state->units[0].type = ENTITY_BIG;

		state->units[1].aggro_target = 0;
		state->units[1].x = 500.0f;
		state->units[1].y = 300.0f;
		state->units[1].target = {600.0f, 200.0f};
		state->units[1].health = 100.0f;
		state->units[1].progress = 0.0f;
		state->units[1].type = ENTITY_MELEE;

		state->enemies[0].aggro_target = 0;
		state->enemies[0].x = 300.0f;
		state->enemies[0].y = 700.0f;
		state->enemies[0].target = {400.0f, 600.0f};
		state->enemies[0].health = 100.0f;
		state->enemies[0].progress = 0.0f;
		state->enemies[0].type = ENTITY_BIG;

		state->enemies[1].aggro_target = 0;
		state->enemies[1].x = 500.0f;
		state->enemies[1].y = 700.0f;
		state->enemies[1].target = {600.0f, 600.0f};
		state->enemies[1].health = 100.0f;
		state->enemies[1].progress = 0.0f;
		state->enemies[1].type = ENTITY_MELEE;

		game_initialized = true;
	}

	/* update */
	state->time_elapsed = get_time_ms() - state->last_time;	
	state->last_time = get_time_ms();

	struct_string money_string;
	char temp_string[512];
	snprintf(temp_string, 512, "MONEY %u", state->money);
	string_create(&money_string, temp_string);

	i32 unit_counter;
	i32 enemy_counter;

	for(unit_counter = 0; unit_counter < NUM_UNITS; unit_counter++)
	{
		update_entity(&(state->units[unit_counter]));
	}

	for(enemy_counter = 0; enemy_counter < NUM_UNITS; enemy_counter++)
	{
		update_entity(&(state->enemies[enemy_counter]));
	}
	/* TODO: update buildings */

	/* render */
	draw_background_in_buffer(
		pixel_buffer,
		pixel_buffer_width, 
		pixel_buffer_height,
		black); 

	for(unit_counter = 0; unit_counter < NUM_UNITS; unit_counter++)
	{
		draw_entity_in_buffer(
			pixel_buffer,
			pixel_buffer_width, 
			pixel_buffer_height,
			state->units[unit_counter],
			blue);
	}
	/* TODO: update buildings */

	for(enemy_counter = 0; enemy_counter < NUM_UNITS; enemy_counter++)
	{
		draw_entity_in_buffer(
			pixel_buffer,
			pixel_buffer_width, 
			pixel_buffer_height,
			state->enemies[enemy_counter],
			red);
	}

	draw_text_in_buffer(
		pixel_buffer,
		pixel_buffer_width, 
		pixel_buffer_height,
		10, 10, 
		2,
		money_string,
		white);

	string_free(&money_string);
}

b8 check_collision_aabb(struct_aabb first, struct_aabb second)
{
	/* if first is not to the left, to the right, above, or below second,
	 * then collison
	 */

	b8 left = false;
	b8 right = false;
	b8 above = false;
	b8 below = false;

	if((first.x + first.w) < second.x)
	{
		left = true;
	}
	if((first.y + first.h) < second.y)
	{
		above = true;
	}
	if(first.x > (second.x + second.w))
	{
		right = true;
	}
	if(first.y > (second.y + second.h))
	{
		below = true;
	}
	if(left || above || right || below) 
	{
		return false;
	}
	return true;
}

void draw_entity_in_buffer(
		u8 *pixel_buffer,
		u16 pixel_buffer_width,
		u16 pixel_buffer_height,
		struct_entity entity,
		struct_rgba_color color)
{
	i32 x = (i32)entity.x;
	i32 y = (i32)entity.y;
	switch(entity.type)
	{
		case ENTITY_BIG:
		{
			/* draw square */
			draw_nofill_rectangle_in_buffer(
					pixel_buffer,
					pixel_buffer_width,
					pixel_buffer_height,
					x - 50, y - 50, 
					100, 100,
					color);
		} break;
		case ENTITY_MELEE:
		{
			/* draw triangle */
			draw_nofill_triangle_in_buffer(
					pixel_buffer,
					pixel_buffer_width,
					pixel_buffer_height,
					x, y - 50, 
					x - 50, y + 50,
					x + 50, y + 50,
					color);
		} break;
		case ENTITY_RANGED:
		{
			/* draw X */
			draw_line_in_buffer(
					pixel_buffer,
					pixel_buffer_width,
					pixel_buffer_height,
					x - 50, y - 50,
					x + 50, y + 50,
					color);
			draw_line_in_buffer(
					pixel_buffer,
					pixel_buffer_width,
					pixel_buffer_height,
					x + 50, y - 50,
					x - 50, y + 50,
					color);
		} break;
		case ENTITY_HARVESTER:
		{
			/* draw diamond */
			i32 points[8] =
				{ x, y + 90,
				  x + 60, y,
				  x, y - 90,
				  x - 60, y };
			draw_nofill_polygon_in_buffer(
					pixel_buffer, 
					pixel_buffer_width, 
					pixel_buffer_height,
					4,
					points, 
					color);

			/* draw health bar */
			draw_nofill_rectangle_in_buffer(
				pixel_buffer,
				pixel_buffer_width, 
				pixel_buffer_height,
				x - 60, y - 130,
				entity.health * 1.2f, 10,
				red);
			/* draw progress bar */
			if(entity.progress > 0.0f)
			{
				draw_nofill_rectangle_in_buffer(
					pixel_buffer,
					pixel_buffer_width, 
					pixel_buffer_height,
					x - 60, y - 160,
					entity.progress * 1.2f, 10,
					purple);
			}
		} break;
		case ENTITY_BARRACKS:
		{
			/* draw circle */
			draw_nofill_circle_in_buffer(
					pixel_buffer,
					pixel_buffer_width,
					pixel_buffer_height,
					x, y, 80.0f,
					color);
		} break;
		case ENTITY_NEXUS:
		{
			/* draw hexagon */
			i32 points[12] =
				{ x + 100, y,
				  x + 50, y + 86,
				  x - 50, y + 86,
				  x - 100, y,
				  x - 50, y - 86,
				  x + 50, y - 86 };
			draw_nofill_polygon_in_buffer(
				pixel_buffer, 
				pixel_buffer_width, 
				pixel_buffer_height,
				6,
				points, 
				color);

			/* draw health bar */
			draw_nofill_rectangle_in_buffer(
				pixel_buffer,
				pixel_buffer_width, 
				pixel_buffer_height,
				x - 80, y - 130,
				entity.health * 1.6f, 10,
				red);
		} break;
		default: 
		{
			_assert(0);
		} break;
	}
}

void update_entity(struct_entity *entity)
{
	/* TODO: if have an aggro target, 
	 *		- if in range, attack
	 *		- else move toward */
	if(entity->aggro_target)
	{
	}
	/* TODO: move toward target */	
	f32 xdist = entity->x - entity->target[0];
	f32 ydist = entity->y - entity->target[1];
	f32 magnitude = sqrtf(xdist * xdist + ydist * ydist);
	f32 xdist_unit = xdist / magnitude;
	f32 ydist_unit = ydist / magnitude;

	if(magnitude > 0.001f)
	{
		entity->x += xdist_unit * MOVE_SPEED_BIG;
		entity->y += ydist_unit * MOVE_SPEED_BIG;
	}

	/* TODO: if at target, look for aggro targets */
}
