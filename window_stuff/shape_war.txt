"GAME DESIGN" DOC for Shape War!

1 resource
3 buildings
- resource harvester (can be built anywhere)
- main building (kill this to win)
- barracks (produce troops)
3 unit types
- medium health melee unit - cheap, fast?
- low health, high damage range unit - cheap-ish, slow?
- high health melee unit, high damage - expensive, slow?

SQUARE for big unit
TRIANGLE for melee unit
X for ranged unit
DIAMOND for harvest building
HEXAGON for main building
CIRCLE for barracks (like 2x2 or smn)
 
blue vs red <- color of shape is which team it's on (obviously)
NOTE: ^ currently have functions to draw all of those

memory management solution
- I might just have the platform layer pass in a pointer to "game memory"
to game_update_and_render. then I'd have separate platform memory for 
like the framebuffer for example. This way the game can do whatever
it wants with the memory, and the platform doesn't have to worry, which
keeps the whole layer division pretty clean.
- How do you feel about transient + also more permanent memory store?
Both can use a bump allocator, but the transient stuff you could treat
like a stack rather than using the stack. You could even have transient
platform memory for like allocating strings in logging functions for
example, etc. <- NOTE: maybe implement this in another game/some other
time
- then just first time through game_update_and_render, have a check
for initialization, and initialize if not initialized. simple, honestly
I like it.
DONE

maybe I start with nexus, and 2 harvesters and just program health
bars for those, and gather resources, and have money go up
ofc now we have to consider like UI
^ things needed for this (this will be next iteration)
[x] rendering progress bars

text rendering to display resources
- here's my thoughts on text rendering:
	- each character has a unique drawing function... 
	- each character is basically a rectangle that scales based on font
	size... even font sizes will render different than odd font sizes
	I guess? 1 pt font is 1 pixel

	so like the letter "I" would be:

					xxx
					 x
					 x
					xxx

					for 1 pt, that's a 4x3 rectangle
						
					for 2 pt?

					xxxxxx
					xxxxxx
					  xx
					  xx
					  xx
					  xx
					xxxxxx
					xxxxxx

					? but maybe that's '4 pt'

					so maybe I'll have a fixed font size for this game?

					I'll see what "font size" looks good I guess.

					I'll use ascii codes so that a string can get
					passed directly, so we loop through string, 
					draw each character starting at x, y (top left of
					first char)
DONE

mouse input, how to get one-click? wish I had a mouse for this 
lol. will need to probably touch up keyboard input as well
	- was_down, is_down, to track just a change in state rather
	than just checking for down (i.e. repeating, but that's useful
	for cases when u want key repeat)
	- mouse has no repeat rate thing happening btw like keyboard does
	- at some point, you'll need to do something similar for keyboard,
	so might as well now

	implementation:
	- so I think I need a platform layer input state that just has
	down or up for each key/button -> so I'd have 2 of those, 
	and every frame you would check the diff between the 2 and that's
	what goes into the game_input state <- game input state should just
	have whether a button's state changed from 0 -> 1 (pressed) or 
	1 -> 0 (released)

	- I'm gonna do an almost full rewrite of the input system from
	platform side. I'll obv keep all the keysym stuff, but like yk
	anyways
DONE

NOTE: still need to get mouse wheel input working, it was being weird
today. basically I think it gives 2 back-to-back events (like the repeat
rate stuff), so I'll have to have some system that peeks the next 
event to check if there's a key repeat/mouse wheel

unit movement, aggro, selection, mouse input commands, etc.
- selection:
	- I think I'll have one "selected entity" in game state
	that responds to any input
- movement
	- each unit has a target location
		- if a unit is aggroed, it will update it's target location
		to be the unit it's aggroed on UNLESS it is within range, then
		just stop and shoot at the enemy
		- aggro gets reset (i.e. target is NULL) whenever a manual move
		command is issued
		- if an attack move command is issued, then unit will scan
		for enemies to add as their aggro target
- so I'm going to create a test scenario with just a few units
	- need a memory allocator at this point to setup the game state
	- need a dynamic array for the unit lists, unless you want to use
	a linked list

NOTE: I'm going to assume a fixed window size of 1920 x 1080 for this
game bc it's not that crazy of a game that I'd actually release, yk

NOTE: I implemented hot-reloading (at least it should work most of the
time I think I eliminated the race condition) so that developing
features/iterating for the game will be faster/easier 

NOTE: after implementing hot-reloading, I realized, that stack variables
in game.c get re-initialized every time the shared object is reloaded.
so ANY data has to be in that game memory buffer that the platform
layer passes. This includes modifying jstring.h to keep it's own state
in the memory that is handed to it as well... I think. I'll have to
make sure util.c and other incuded files in game.c don't also have
stack variables that'll get re-initialized.
- okay, fixed... I just reactivate jstring memory every frame bc
we reset it anyway

next up:
game state
	- nexus
		- health
		- position
	- *your_units
		- health
		- position
	- *your_buildings
		- health
		- position
		- progress (if applicable)
	- your current "money"
	- *enemy_units
		- health
		- position

game loop:
	- your units
		- if no target, check for enemies to acquire target
		- if target
			- if in range, and attack not on cooldown
			- else move toward target
		- else	
			- if target move position, move toward there
			- else do nothing
	- enemy units same thing
	- your buildings
		- update progress

			this can be reordered ofc just getting the gist down

so a nice "entity" struct
{
	i32 health;
	i32 x, y; <- position
	u32 progress; <- always 0 for anything other than barracks/harvester
						WAIT maybe this is how u track attack cooldowns?
}

TODO: get all of the above done
