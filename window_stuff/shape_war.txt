"GAME DESIGN" DOC for Shape War!

memory management solution
- I might just have the platform layer pass in a pointer to "game memory"
to game_update_and_render. then I'd have separate platform memory for 
like the framebuffer for example. This way the game can do whatever
it wants with the memory, and the platform doesn't have to worry, which
keeps the whole layer division pretty clean.
- How do you feel about transient + also more permanent memory store?
Both can use a bump allocator, but the transient stuff you could treat
like a stack rather than using the stack. You could even have transient
platform memory for like allocating strings in logging functions for
example, etc. <- NOTE: maybe implement this in another game/some other
time
- then just first time through game_update_and_render, have a check
for initialization, and initialize if not initialized. simple, honestly
I like it.
DONE

text rendering to display resources
- here's my thoughts on text rendering:
	- each character has a unique drawing function... 
	- each character is basically a rectangle that scales based on font
	size... even font sizes will render different than odd font sizes
	I guess? 1 pt font is 1 pixel

	so like the letter "I" would be:

					xxx
					 x
					 x
					xxx

					for 1 pt, that's a 4x3 rectangle
						
					for 2 pt?

					xxxxxx
					xxxxxx
					  xx
					  xx
					  xx
					  xx
					xxxxxx
					xxxxxx

					? but maybe that's '4 pt'

					so maybe I'll have a fixed font size for this game?

					I'll see what "font size" looks good I guess.

					I'll use ascii codes so that a string can get
					passed directly, so we loop through string, 
					draw each character starting at x, y (top left of
					first char)
DONE

mouse input, how to get one-click? wish I had a mouse for this 
lol. will need to probably touch up keyboard input as well
	- was_down, is_down, to track just a change in state rather
	than just checking for down (i.e. repeating, but that's useful
	for cases when u want key repeat)
	- mouse has no repeat rate thing happening btw like keyboard does
	- at some point, you'll need to do something similar for keyboard,
	so might as well now

	implementation:
	- so I think I need a platform layer input state that just has
	down or up for each key/button -> so I'd have 2 of those, 
	and every frame you would check the diff between the 2 and that's
	what goes into the game_input state <- game input state should just
	have whether a button's state changed from 0 -> 1 (pressed) or 
	1 -> 0 (released)

	- I'm gonna do an almost full rewrite of the input system from
	platform side. I'll obv keep all the keysym stuff, but like yk
	anyways
DONE

NOTE: I implemented hot-reloading (at least it should work most of the
time I think I eliminated the race condition) so that developing
features/iterating for the game will be faster/easier 

NOTE: after implementing hot-reloading, I realized, that stack variables
in game.c get re-initialized every time the shared object is reloaded.
so ANY data has to be in that game memory buffer that the platform
layer passes. This includes modifying jstring.h to keep it's own state
in the memory that is handed to it as well... I think. I'll have to
make sure util.c and other incuded files in game.c don't also have
stack variables that'll get re-initialized.
- okay, fixed... I just reactivate jstring memory every frame bc
we reset it anyway

Oct 6, 2025

	I'm going to need to add some rendering functionality
	- world space -> screen space
	- rotating shapes
		- multiply vertices of shapes (in object space) by a 2x2 rotation
		matrix with the desired basis vectors.
	
	shape:
		- has object space vertices
		- has world space position

		rendering is done by translating object space vertices to world
		space (simple translation), then to screen space, and drawing a 
		line between each vertex (i.e. calling draw_polygon or whatever
		it's called)

	CURRENT GOAL: render a triangle that rotates every 0.5 seconds or
	smn
	DONE

	NEXT GOAL:
	be able to render all the different shape war shapes, and rotate
	them:
	- square
	- diamond
	- trapezoid
	- hexagon
	- devise some way to store them in memory that makes sense, and
	code that allows you to easily add more to the "scene"
		- probably like a dynamic array of vertices that you push
		onto the end of when you add a shape to the scene. that way
		you can also arbitrarily remove shapes as well (at least with
		an implementation that has a delete_at function of some sort)
		- this darray implementation should not resize when the end is
		reached, it should instead just not allow pushing when there's
		not enough space left

	NEXT NEXT GOAL:
	- mouse click on shapes detection: i.e. code that let's me drag
	shapes around
	- collision detection between shapes
	- getting that stuff working allows us to at least reason about
	how to do the shape combining code

